\chapter{UIProtocol}
This chapter introduces the reader to the UIProtocol, its architecture and communication between client and server.
%Analyse UIP platform, focus on UIP client design.

\section{About UIProtocol}
Universal Interface Protocol (UIProtocol) is a user interface specification language \cite{uip} being developed at FEE CTU for research purposes. At the time of writing this thesis, the specification is not publicly available. UIProtocol provides means for describing user interfaces and transferring data related to interaction between user and an UIProtocol based application. It is designed to be cross-platform, programming language independent and easily localized.\\
UIProtocol is an XML based application protocol that allows for describing the hierarchical structure of the GUI along with the placement and visual appearance of the containers and components. It is designed for a client-server system and for facilitating client-server applications it defines the communication rules between client and server. The communication  is based on exchange of XML documents which contain all components and values needed for rendering the UI. The client first initiates the communication and receives respective XML description from the server. The description can be of four different types: interfaces, i.e. the UI components and containers, models which contain the data displayed and actions. The communication from client to server only consists of event descriptions. For example, when a user presses a button, the event information is sent to the server which responds by model and/or interface update.\\
An example of such situation may be a user requesting a weather app to his handheld device. As he enters his location and presses a button to request the weather information, part of the job is done directly by the client and the other is sent to the server. The part done directly at the client are easy tasks, such as visual effects when pressing the button. Even these effects can be, ahead of time, specified by information from the server. The request for weather is then sent to the server (event), which processes the information and responds by sending the interface structure, components and the weather information. This is then displayed to the user who than has other options to interact with the app.

The documents of UIProtocol can be sent in either direction usually through a single channel without waiting for a request, e.g. server can send updates to the client as soon as the displayed information needs to be updated, without having to wait for an update request. Should an application not communicate with a remote server, there is the possibility of both client and server running on the same machine although this is not a typical usage.

\subsection{UIProtocol Client}
UIProtocol client is thin, i.e. no application code is executed on the client side. The device running the client is thought to be the the one user directly uses, that is, it renders the content to the user and receives input from them. From the UIProtocol point of view, the client device is also considered insecure, i.e. the device may be misused to send invalid data to the server and may be used to attack it. The UIP client may not implement the whole feature set defined by UIProtocol. What has to be implemented is the minimal functionality that is able to render a user interface, sending event information to the server and update the application it by data coming from it.

\subsection{UIProtocol Server}
UIProtocol is the part of the architecture which is responsible for evaluating the client events and sending a correct response - this is where the application logic is executed. It must be able to service multiple client simultaneously and is intended to run on a machine which is considered safe.

\subsection{Elements of UIProtocol Communication}
As mentioned previously, the information exchange between client and server concerns Interfaces, Models, Actions (which are sent from server to client) and events (sent from client to server). In the following subsections we will describe these in greater detail and also include more information on UIP syntax.

\subsubsection{Syntax of UIProtocol}
The UIP document syntax is shown below in Listing \ref{uipSyntax} which shows the four possible tags with the root element, with the actions tag being optional. The tags define the behavior of the application and are covered later in the chapter, with the exception of actions tag.

\lstinputlisting[label=uipSyntax,caption=UIP document Syntax]{sources/uipSyntax.xml}

Every UIProtocol document must contain an XML header with the version and encoding (UTF-8 recommended).

\subsubsection{Interfaces}
Interface describes the structure and components of the user interface. Every interface can nest containers and elements that form a part of user interface. An example can be seen in Listing \ref{uipInterface}. The listing includes containers and elements of different types, for example "public.input.text" is a standard component which will be rendered as an element into which a user can enter text. It also shows how interfaces can be embedded. This is done by including an element or container with class name corresponding to different interface's class. The interfaces are uniquely identified by the class attribute (unlike most other objects in UIProtocol and other markup languages identified by id attribute). Note that element tag can have an id attribute, as shown.\\

\lstinputlisting[label=uipInterface,caption=Interface Description Example]{sources/interfaces.xml}

\subsubsection{Events}
Events inform the server that some action was triggered at the client side (e.g. a button press) or that there was some other update (e.g. change in sensor readings). This is the basic mechanism of client to server communication and therefore has to be supported by client. The event element contains a unique id which specifies the event source. An event can contain any number of properties which describe it more closely. An example is shown in Listing \ref{uipEvents}.
\lstinputlisting[label=uipEvents,caption=Events Example]{sources/uipEvents.xml}

\subsubsection{Models}
Models serve as the storage for data that is displayed to the user. A model contains data in properties which are uniquely identified by key attribute. The key is separated by colon into two parts - first referencing a model and second referencing a property within the model. When changing the contents of a model, all of the UI elements bound to the model by the key attribute are updated. UIP provides support for this binding and therefore updating the app contents is made easy. For example, there may be two representations of humidity level in a given environment (text and a graphical representation). If they are both bound to the same model, changing the respective property within that model will be immediately reflected.

\subsubsection{Properties}
Properties are the most nested elements of an UIP document and define the visual appearance, positioning of GUI objects and more. Every property has to have a name, which defines what feature of the connected object is described by this property. For example the property in Listing \ref{uipInterface} with name text defines the text displayed in the text field. Value is a constant that will define the text. The mentioned property also contains the key attribute which binds the displayed value to a model. The part before the colon references a model and the part after colon references a property within the model. That is, if there is a model gui with property fstName, the value of the property is used. Moreover, whenever the value of the referenced property is updated, the update is automatically reflected in all other bound properties.

\endinput